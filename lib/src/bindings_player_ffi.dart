// this file is not the one generated by ffiGen.
// ffiGen will generate [flutter_soloud_bindings_ffi_TMP.dart]
// from [ffi_gen_tmp.h] file. Read notes in the latter
// ignore_for_file: avoid_positional_boolean_parameters, require_trailing_commas

import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart';
import 'package:flutter_soloud/src/enums.dart';
import 'package:flutter_soloud/src/sound_handle.dart';
import 'package:flutter_soloud/src/sound_hash.dart';
import 'package:logging/logging.dart';

/// FFI bindings to SoLoud
class FlutterSoLoudFfi {
  static final Logger _log = Logger('flutter_soloud.FlutterSoLoudFfi');

  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  // ignore: sort_constructors_first
  FlutterSoLoudFfi(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  // ignore: sort_constructors_first
  FlutterSoLoudFfi.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// FOR NOW THIS CALLBACK IS NOT USED
  ///
//   /// Since using the callback passed to [setPlayEndedCallback] will throw
//   /// ```Error: fromFunction expects a static function as parameter.
//   /// dart:ffi only supports calling static Dart functions from native code.
//   /// Closures and tear-offs are not supported because
//   /// they can capture context.```
//   static void Function(int)? _userPlayEndedCallback;
//   /// here the user callback given to [setPlayEndedCallback] will be temporarly
// /// saved into [_userPlayEndedCallback]. The [_playEndedCallback] will instead
// /// passed to C side to be called, which then call the user callback.
//   static void _playEndedCallback(int handle) {
//     if (_userPlayEndedCallback != null) {
//       // ignore: prefer_null_aware_method_calls
//       _userPlayEndedCallback!(handle);
//     }
//   }
//   /// @brief Set a dart function to call when the sound with [handle] handle ends
//   /// @param callback this is the dart function that will be called
//   ///     when the sound ends to play.
//   ///     Must be global or a static class member:
//   ///     ```@pragma('vm:entry-point')
//   ///        void playEndedCallback(int handle) {
//   ///             // here the sound with [handle] has ended.
//   ///             // you can play again
//   ///             soLoudController.soLoudFFI.play(handle);
//   ///             // or dispose it
//   ///             soLoudController.soLoudFFI.stop(handle);
//   ///        }
//   ///     ```
//   /// @param handle the handle to the sound
//   /// @return callback this is the dart function that will be called
//   ///         when the sound ends to play
//   /// @return true if success;
//   /// https://github.com/dart-lang/sdk/issues/37022
//   /// PS: NOT USED, maybe in another time
//   bool setPlayEndedCallback(
//     void Function(int) callback,
//     int handle,
//   ) {

//     _userPlayEndedCallback = callback;
//     final ret = _setPlayEndedCallback(
//       ffi.Pointer.fromFunction(_playEndedCallback),
//       handle,
//     );

//     return ret == 1 ? true : false;
//   }

//   late final _setPlayEndedCallbackPtr = _lookup<
//       ffi.NativeFunction<
//           ffi.Int Function(
//               ffi.Pointer<
//                   ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>,
//               ffi.UnsignedInt)>>('setPlayEndedCallback');
//   late final _setPlayEndedCallback = _setPlayEndedCallbackPtr.asFunction<
//       int Function(
//         ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>,
//         int)>();

  /// Initialize the player. Must be called before any other player functions
  ///
  /// Returns [PlayerErrors.noError] if success
  PlayerErrors initEngine() {
    return PlayerErrors.values[_initEngine()];
  }

  late final _initEnginePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('initEngine');
  late final _initEngine = _initEnginePtr.asFunction<int Function()>();

  /// Must be called when there is no more need of the player
  /// or when closing the app
  ///
  void deinit() {
    return _dispose();
  }

  late final _disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispose');
  late final _dispose = _disposePtr.asFunction<void Function()>();

  /// Gets the state of player
  ///
  /// Return true if initilized
  bool isInited() {
    return _isInited() == 1;
  }

  late final _isInitedPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>(
    'isInited',
  );
  late final _isInited = _isInitedPtr.asFunction<int Function()>();

  /// Load a new sound to be played once or multiple times later
  ///
  /// [completeFileName] the complete file path
  /// [soundHash] return hash of the sound
  /// Returns [PlayerErrors.noError] if success
  ({PlayerErrors error, int soundHash}) loadMemory(ffi.Pointer<ffi.Float> buffer, int hash, int length ) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> h =
    calloc(ffi.sizeOf<ffi.UnsignedInt>());
    final ffi.Pointer<ffi.UnsignedInt> l =
    calloc(ffi.sizeOf<ffi.UnsignedInt>());

    final e = _loadMemory(
        buffer,
        h,
        l
    );
    final ret = (error: PlayerErrors.values[e], soundHash: h.value);
    calloc.free(h);
    calloc.free(l);
    return ret;
  }

  late final _loadMemoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>
              )>>('loadMemory');
  late final _loadMemory = _loadMemoryPtr.asFunction<
      int Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.UnsignedInt>)>();


  /// Load a new sound to be played once or multiple times later.
  ///
  /// [completeFileName] the complete file path.
  /// [LoadMode] if `LoadMode.memory`, Soloud::wav will be used which loads
  /// all audio data into memory. Used to prevent gaps or lags
  /// when seeking/starting a sound (less CPU, more memory allocated).
  /// If `LoadMode.disk` is used, the audio data is loaded
  /// from the given file when needed (more CPU, less memory allocated).
  /// See the [seek] note problem when using [LoadMode] = `LoadMode.disk`.
  /// `soundHash` return hash of the sound.
  /// Returns [PlayerErrors.noError] if success.
  ({PlayerErrors error, SoundHash soundHash}) loadFile(
    String completeFileName,
    LoadMode mode,
  ) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> h =
        calloc(ffi.sizeOf<ffi.UnsignedInt>());
    final e = _loadFile(
      completeFileName.toNativeUtf8().cast<ffi.Char>(),
      mode == LoadMode.memory ? 1 : 0,
      h,
    );
    final soundHash = SoundHash(h.value);
    final ret = (error: PlayerErrors.values[e], soundHash: soundHash);
    calloc.free(h);
    return ret;
  }

  late final _loadFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Pointer<ffi.UnsignedInt>,
          )>>('loadFile');
  late final _loadFile = _loadFilePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Load a new waveform to be played once or multiple times later
  ///
  /// [waveform]
  /// [superWave]
  /// [scale]
  /// [detune]
  /// `soundHash` return hash of the sound
  /// Returns [PlayerErrors.noError] if success
  ({PlayerErrors error, SoundHash soundHash}) loadWaveform(
    WaveForm waveform,
    bool superWave,
    double scale,
    double detune,
  ) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> h =
        calloc(ffi.sizeOf<ffi.UnsignedInt>());
    final e = _loadWaveform(
      waveform.index,
      superWave ? 1 : 0,
      scale,
      detune,
      h,
    );
    final soundHash = SoundHash(h.value);
    final ret = (error: PlayerErrors.values[e], soundHash: soundHash);
    calloc.free(h);
    return ret;
  }

  late final _loadWaveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int, ffi.Int, ffi.Float, ffi.Float,
              ffi.Pointer<ffi.UnsignedInt>)>>('loadWaveform');
  late final _loadWaveform = _loadWaveformPtr.asFunction<
      int Function(int, int, double, double, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Set the scale of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newScale]
  void setWaveformScale(SoundHash hash, double newScale) {
    return _setWaveformScale(hash.hash, newScale);
  }

  late final _setWaveformScalePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformScale');
  late final _setWaveformScale =
      _setWaveformScalePtr.asFunction<void Function(int, double)>();

  /// Set the detune of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newDetune]
  void setWaveformDetune(SoundHash hash, double newDetune) {
    return _setWaveformDetune(hash.hash, newDetune);
  }

  late final _setWaveformDetunePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformDetune');
  late final _setWaveformDetune =
      _setWaveformDetunePtr.asFunction<void Function(int, double)>();

  /// Set a new frequency of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newFreq]
  void setWaveformFreq(SoundHash hash, double newFreq) {
    return _setWaveformFreq(hash.hash, newFreq);
  }

  late final _setWaveformFreqPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformFreq');
  late final _setWaveformFreq =
      _setWaveformFreqPtr.asFunction<void Function(int, double)>();

  /// Set a new frequence of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [superwave]
  void setWaveformSuperWave(SoundHash hash, int superwave) {
    return _setSuperWave(hash.hash, superwave);
  }

  late final _setSuperWavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setSuperWave');
  late final _setSuperWave =
      _setSuperWavePtr.asFunction<void Function(int, int)>();

  /// Set a new wave form of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newWaveform]  WAVE_SQUARE = 0,
  /// WAVE_SAW,
  /// WAVE_SIN,
  /// WAVE_TRIANGLE,
  /// WAVE_BOUNCE,
  /// WAVE_JAWS,
  /// WAVE_HUMPS,
  /// WAVE_FSQUARE,
  /// WAVE_FSAW
  void setWaveform(SoundHash hash, WaveForm newWaveform) {
    return _setWaveform(hash.hash, newWaveform.index);
  }

  late final _setWaveformPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setWaveform');
  late final _setWaveform =
      _setWaveformPtr.asFunction<void Function(int, int)>();

  /// Speech the text given
  ///
  /// [textToSpeech]
  /// Returns PlayerErrors.noError if success and handle sound identifier
  // TODO(marco): add other T2S parameters
  ({PlayerErrors error, SoundHandle handle}) speechText(String textToSpeech) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> handle = calloc();
    final e = _speechText(
      textToSpeech.toNativeUtf8().cast<ffi.Char>(),
      handle,
    );
    final ret =
        (error: PlayerErrors.values[e], handle: SoundHandle(handle.value));
    calloc.free(handle);
    return ret;
  }

  late final _speechTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedInt>,
          )>>('speechText');
  late final _speechText = _speechTextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Switch pause state of an already loaded sound identified by [handle]
  ///
  /// [handle] the sound handle
  void pauseSwitch(SoundHandle handle) {
    return _pauseSwitch(handle.id);
  }

  late final _pauseSwitchPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
    'pauseSwitch',
  );
  late final _pauseSwitch = _pauseSwitchPtr.asFunction<void Function(int)>();

  /// Pause or unpause already loaded sound identified by [handle]
  ///
  /// [handle] the sound handle
  /// [pause] the sound handle
  void setPause(SoundHandle handle, int pause) {
    return _setPause(handle.id, pause);
  }

  late final _setPausePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setPause');
  late final _setPause = _setPausePtr.asFunction<void Function(int, int)>();

  /// Gets the pause state
  ///
  /// [handle] the sound handle
  /// Return true if paused
  bool getPause(SoundHandle handle) {
    return _getPause(handle.id) == 1;
  }

  late final _getPausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
    'getPause',
  );
  late final _getPause = _getPausePtr.asFunction<int Function(int)>();

  /// Set a sound's relative play speed.
  /// Setting the value to 0 will cause undefined behavior, likely a crash.
  /// Change the relative play speed of a sample. This changes the effective
  /// sample rate while leaving the base sample rate alone.
  ///
  /// Note that playing a sound at a higher sample rate will require SoLoud
  /// to request more samples from the sound source, which will require more
  /// memory and more processing power. Playing at a slower sample
  /// rate is cheaper.
  ///
  /// [handle] the sound handle
  /// [speed] the new speed
  void setRelativePlaySpeed(SoundHandle handle, double speed) {
    return _setRelativePlaySpeed(handle.id, speed);
  }

  late final _setRelativePlaySpeedPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setRelativePlaySpeed');
  late final _setRelativePlaySpeed =
      _setRelativePlaySpeedPtr.asFunction<void Function(int, double)>();

  /// Return the current play speed.
  ///
  /// [handle] the sound handle
  double getRelativePlaySpeed(SoundHandle handle) {
    return _getRelativePlaySpeed(handle.id);
  }

  late final _getRelativePlaySpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.UnsignedInt)>>(
          'getRelativePlaySpeed');
  late final _getRelativePlaySpeed =
      _getRelativePlaySpeedPtr.asFunction<double Function(int)>();

  /// Play already loaded sound identified by [soundHash]
  ///
  /// [soundHash] the unique sound hash of a sound
  /// [volume] 1.0 full volume
  /// [pan] 0.0 centered
  /// [paused] false not paused
  /// [looping] whether to start the sound in looping state.
  /// [loopingStartAt] If looping is enabled, the loop point is, by default,
  /// the start of the stream. The loop start point can be set with this
  /// parameter, and current loop point can be queried with `getLoopingPoint()`
  /// and changed by `setLoopingPoint()`.
  /// Return the error if any and a new `newHandle` of this sound
  ({PlayerErrors error, SoundHandle newHandle}) play(
    SoundHash soundHash, {
    double volume = 1,
    double pan = 0,
    bool paused = false,
    bool looping = false,
    Duration loopingStartAt = Duration.zero,
  }) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> handle = calloc();
    final e = _play(
      soundHash.hash,
      volume,
      pan,
      paused ? 1 : 0,
      looping ? 1 : 0,
      loopingStartAt.toDouble(),
      handle,
    );
    final ret =
        (error: PlayerErrors.values[e], newHandle: SoundHandle(handle.value));
    calloc.free(handle);
    return ret;
  }

  late final _playPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float, ffi.Int,
              ffi.Int, ffi.Double, ffi.Pointer<ffi.UnsignedInt>)>>('play');
  late final _play = _playPtr.asFunction<
      int Function(int, double, double, int, int, double,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Stop already loaded sound identified by [handle] and clear it.
  ///
  /// [handle]
  void stop(SoundHandle handle) {
    return _stop(handle.id);
  }

  late final _stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('stop');
  late final _stop = _stopPtr.asFunction<void Function(int)>();

  /// Stop all handles of the already loaded sound identified
  /// by [soundHash] and dispose it.
  ///
  /// [soundHash]
  void disposeSound(SoundHash soundHash) {
    return _disposeSound(soundHash.hash);
  }

  late final _disposeSoundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
    'disposeSound',
  );
  late final _disposeSound = _disposeSoundPtr.asFunction<void Function(int)>();

  /// Dispose all sounds already loaded
  void disposeAllSound() {
    return _disposeAllSound();
  }

  late final _disposeAllSoundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('disposeAllSound');
  late final _disposeAllSound =
      _disposeAllSoundPtr.asFunction<void Function()>();

  /// Query whether a sound is set to loop.
  ///
  /// [handle]
  /// Returns true if flagged for looping.
  bool getLooping(SoundHandle handle) {
    return _getLooping(handle.id) == 1;
  }

  late final _getLoopingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'getLooping');
  late final _getLooping = _getLoopingPtr.asFunction<int Function(int)>();

  /// This function can be used to set a sample to play on repeat,
  /// instead of just playing once
  ///
  /// [handle]
  /// [enable]
  void setLooping(SoundHandle handle, bool enable) {
    return _setLooping(handle.id, enable ? 1 : 0);
  }

  late final _setLoopingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
    'setLooping',
  );
  late final _setLooping = _setLoopingPtr.asFunction<void Function(int, int)>();

  /// Get sound loop point value.
  ///
  /// [handle]
  /// Returns the duration.
  Duration getLoopPoint(SoundHandle handle) {
    return _getLoopPoint(handle.id).toDuration();
  }

  late final _getLoopPointPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
          'getLoopPoint');
  late final _getLoopPoint =
      _getLoopPointPtr.asFunction<double Function(int)>();

  /// Set sound loop point value.
  ///
  /// [handle]
  /// [timestamp]
  void setLoopPoint(SoundHandle handle, Duration timestamp) {
    _setLoopPoint(handle.id, timestamp.toDouble());
  }

  late final _setLoopPointPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Double)>>(
      'setLoopPoint');
  late final _setLoopPoint =
      _setLoopPointPtr.asFunction<void Function(int, double)>();

  // TODO(marco): implement Soloud.getLoopCount() also?

  /// Enable or disable visualization
  ///
  /// [enabled] enable or disable it
  void setVisualizationEnabled(bool enabled) {
    return _setVisualizationEnabled(
      enabled ? 1 : 0,
    );
  }

  late final _setVisualizationEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
    'setVisualizationEnabled',
  );
  late final _setVisualizationEnabled =
      _setVisualizationEnabledPtr.asFunction<void Function(int)>();

  /// Get visualization state
  ///
  /// Return true if enabled
  bool getVisualizationEnabled() {
    return _getVisualizationEnabled() == 1;
  }

  late final _getVisualizationEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'getVisualizationEnabled');
  late final _getVisualizationEnabled =
      _getVisualizationEnabledPtr.asFunction<int Function()>();

  /// Returns valid data only if VisualizationEnabled is true
  ///
  /// [fft]
  /// Return a 256 float array containing FFT data.
  void getFft(ffi.Pointer<ffi.Float> fft) {
    return _getFft(fft);
  }

  late final _getFftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getFft',
  );
  late final _getFft =
      _getFftPtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Returns valid data only if VisualizationEnabled is true
  ///
  /// fft
  /// Return a 256 float array containing wave data.
  void getWave(ffi.Pointer<ffi.Float> wave) {
    return _getWave(wave);
  }

  late final _getWavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getWave',
  );
  late final _getWave =
      _getWavePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Smooth FFT data.
  /// When new data is read and the values are decreasing, the new value will be
  /// decreased with an amplitude between the old and the new value.
  /// This will result on a less shaky visualization.
  ///
  /// [smooth] must be in the [0.0 ~ 1.0] range.
  /// 0 = no smooth
  /// 1 = full smooth
  /// the new value is calculated with:
  /// newFreq = smooth * oldFreq + (1 - smooth) * newFreq
  void setFftSmoothing(double smooth) {
    return _setFftSmoothing(smooth);
  }

  late final _setFftSmoothingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
    'setFftSmoothing',
  );
  late final _setFftSmoothing =
      _setFftSmoothingPtr.asFunction<void Function(double)>();

  /// Return in [samples] a 512 float array.
  /// The first 256 floats represent the FFT frequencies data [>=0.0].
  /// The other 256 floats represent the wave data (amplitude) [-1.0~1.0].
  ///
  /// [samples] should be allocated and freed in dart side
  void getAudioTexture(ffi.Pointer<ffi.Float> samples) {
    return _getAudioTexture(samples);
  }

  late final _getAudioTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getAudioTexture',
  );
  late final _getAudioTexture =
      _getAudioTexturePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Return a floats matrix of 256x512
  /// Every row are composed of 256 FFT values plus 256 of wave data
  /// Every time is called, a new row is stored in the
  /// first row and all the previous rows are shifted
  /// up (the last one will be lost).
  ///
  /// [samples]
  PlayerErrors getAudioTexture2D(ffi.Pointer<ffi.Pointer<ffi.Float>> samples) {
    if (samples == ffi.nullptr) return PlayerErrors.nullPointer;
    final ret = _getAudioTexture2D(samples);
    return PlayerErrors.values[ret];
  }

  late final _getAudioTexture2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Pointer<ffi.Float>>,
          )>>('getAudioTexture2D');
  late final _getAudioTexture2D = _getAudioTexture2DPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Float>>)>();

  /// Get the sound length.
  ///
  /// [soundHash] the sound hash
  /// Returns sound length in seconds
  Duration getLength(SoundHash soundHash) {
    return _getLength(soundHash.hash).toDuration();
  }

  late final _getLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
    'getLength',
  );
  late final _getLength = _getLengthPtr.asFunction<double Function(int)>();

  /// Seek playing in [time] seconds
  /// [time]
  /// [handle] the sound handle
  /// Returns [PlayerErrors.noError] if success
  ///
  /// NOTE: when seeking an MP3 file loaded using `mode`=`LoadMode.disk` the
  /// seek operation is performed but there will be delays. This occurs because
  /// the MP3 codec must compute each frame length to gain a new position.
  /// The problem is explained in souloud_wavstream.cpp
  /// in `WavStreamInstance::seek` function.
  ///
  /// This mode is useful ie for background music, not for a music player
  /// where a seek slider for MP3s is a must.
  /// If you need to seek MP3s without lags, please, use
  /// `mode`=`LoadMode.memory` instead or other supported audio formats!
  ///
  int seek(SoundHandle handle, Duration time) {
    return _seek(handle.id, time.toDouble());
  }

  late final _seekPtr = _lookup<
      ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
    'seek',
  );
  late final _seek = _seekPtr.asFunction<int Function(int, double)>();

  /// Get current sound position  in seconds
  ///
  /// [handle] the sound handle
  /// Returns time
  Duration getPosition(SoundHandle handle) {
    return _getPosition(handle.id).toDuration();
  }

  late final _getPositionPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
    'getPosition',
  );
  late final _getPosition = _getPositionPtr.asFunction<double Function(int)>();

  /// Get current Global volume
  ///
  /// Returns the volume
  double getGlobalVolume() {
    return _getGlobalVolume();
  }

  late final _getGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('getGlobalVolume');
  late final _getGlobalVolume =
      _getGlobalVolumePtr.asFunction<double Function()>();

  /// Set current Global volume
  ///
  /// Returns [PlayerErrors.noError] if success
  int setGlobalVolume(double volume) {
    return _setGlobalVolume(volume);
  }

  late final _setGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>(
          'setGlobalVolume');
  late final _setGlobalVolume =
      _setGlobalVolumePtr.asFunction<int Function(double)>();

  /// Get current [handle] volume
  ///
  /// Returns the volume
  double getVolume(SoundHandle handle) {
    return _getVolume(handle.id);
  }

  late final _getVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
          'getVolume');
  late final _getVolume = _getVolumePtr.asFunction<double Function(int)>();

  /// Set current [handle] volume
  ///
  /// Returns [PlayerErrors.noError] if success
  int setVolume(SoundHandle handle, double volume) {
    return _setVolume(handle.id, volume);
  }

  late final _setVolumePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'setVolume');
  late final _setVolume = _setVolumePtr.asFunction<int Function(int, double)>();

  /// Check if a handle is still valid.
  ///
  /// [handle] handle to check
  /// Return true if it still exists
  bool getIsValidVoiceHandle(SoundHandle handle) {
    return _getIsValidVoiceHandle(handle.id) == 1;
  }

  late final _getIsValidVoiceHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
    'getIsValidVoiceHandle',
  );
  late final _getIsValidVoiceHandle =
      _getIsValidVoiceHandlePtr.asFunction<int Function(int)>();

  /// Returns the number of concurrent sounds that are playing at the moment.
  int getActiveVoiceCount() {
    return _getActiveVoiceCount();
  }

  late final _getActiveVoiceCountPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'getActiveVoiceCount');
  late final _getActiveVoiceCount =
      _getActiveVoiceCountPtr.asFunction<int Function()>();

  /// Returns the number of concurrent sounds that are playing a
  /// specific audio source.
  int countAudioSource(SoundHash soundHash) {
    return _countAudioSource(soundHash.hash);
  }

  late final _countAudioSourcePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'countAudioSource');
  late final _countAudioSource =
      _countAudioSourcePtr.asFunction<int Function(int)>();

  /// Returns the number of voices the application has told SoLoud to play.
  int getVoiceCount() {
    return _getVoiceCount();
  }

  late final _getVoiceCountPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>('getVoiceCount');
  late final _getVoiceCount = _getVoiceCountPtr.asFunction<int Function()>();

  /// Get a sound's protection state.
  bool getProtectVoice(SoundHandle handle) {
    return _getProtectVoice(handle.id) == 1;
  }

  late final _getProtectVoicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'getProtectVoice');
  late final _getProtectVoice =
      _getProtectVoicePtr.asFunction<int Function(int)>();

  /// Set a sound's protection state.
  ///
  /// Normally, if you try to play more sounds than there are voices,
  /// SoLoud will kill off the oldest playing sound to make room.
  /// This will most likely be your background music. This can be worked
  /// around by protecting the sound.
  /// If all voices are protected, the result will be undefined.
  ///
  /// [handle]  handle to check.
  /// [protect] whether to protect or not.
  void setProtectVoice(SoundHandle handle, bool protect) {
    return _setProtectVoice(handle.id, protect ? 1 : 0);
  }

  late final _setProtectVoicePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setProtectVoice');
  late final _setProtectVoice =
      _setProtectVoicePtr.asFunction<void Function(int, int)>();

  /// Get the current maximum active voice count.
  int getMaxActiveVoiceCount() {
    return _getMaxActiveVoiceCount();
  }

  late final _getMaxActiveVoiceCountPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'getMaxActiveVoiceCount');
  late final _getMaxActiveVoiceCount =
      _getMaxActiveVoiceCountPtr.asFunction<int Function()>();

  /// Set the current maximum active voice count.
  /// If voice count is higher than the maximum active voice count,
  /// SoLoud will pick the ones with the highest volume to actually play.
  /// [maxVoiceCount] the max concurrent sounds that can be played.
  ///
  /// NOTE: The number of concurrent voices is limited, as having unlimited
  /// voices would cause performance issues, as well as lead to unnecessary
  /// clipping. The default number of concurrent voices is 16, but this can be
  /// adjusted at runtime. The hard maximum number is 4095, but if more are
  /// required, SoLoud can be modified to support more. But seriously, if you
  /// need more than 4095 sounds at once, you're probably going to make
  /// some serious changes in any case.
  void setMaxActiveVoiceCount(int maxVoiceCount) {
    return _setMaxActiveVoiceCount(maxVoiceCount);
  }

  late final _setMaxActiveVoiceCountPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'setMaxActiveVoiceCount');
  late final _setMaxActiveVoiceCount =
      _setMaxActiveVoiceCountPtr.asFunction<void Function(int)>();

  /////////////////////////////////////////
  /// faders
  /////////////////////////////////////////

  /// Smoothly change the global volume over specified [duration].
  ///
  int fadeGlobalVolume(double to, Duration duration) {
    return _fadeGlobalVolume(to, duration.toDouble());
  }

  late final _fadeGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float, ffi.Float)>>(
          'fadeGlobalVolume');
  late final _fadeGlobalVolume =
      _fadeGlobalVolumePtr.asFunction<int Function(double, double)>();

  /// Smoothly change a channel's volume over specified [duration].
  ///
  int fadeVolume(SoundHandle handle, double to, Duration duration) {
    return _fadeVolume(handle.id, to, duration.toDouble());
  }

  late final _fadeVolumePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadeVolume');
  late final _fadeVolume =
      _fadeVolumePtr.asFunction<int Function(int, double, double)>();

  /// Smoothly change a channel's pan setting over specified [duration].
  ///
  int fadePan(SoundHandle handle, double to, Duration duration) {
    return _fadePan(handle.id, to, duration.toDouble());
  }

  late final _fadePanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadePan');
  late final _fadePan =
      _fadePanPtr.asFunction<int Function(int, double, double)>();

  /// Smoothly change a channel's relative play speed over specified time.
  ///
  int fadeRelativePlaySpeed(SoundHandle handle, double to, Duration time) {
    return _fadeRelativePlaySpeed(handle.id, to, time.toDouble());
  }

  late final _fadeRelativePlaySpeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadeRelativePlaySpeed');
  late final _fadeRelativePlaySpeed =
      _fadeRelativePlaySpeedPtr.asFunction<int Function(int, double, double)>();

  /// After specified [duration], pause the channel.
  ///
  int schedulePause(SoundHandle handle, Duration duration) {
    return _schedulePause(handle.id, duration.toDouble());
  }

  late final _schedulePausePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'schedulePause');
  late final _schedulePause =
      _schedulePausePtr.asFunction<int Function(int, double)>();

  /// After specified time, stop the channel.
  ///
  int scheduleStop(SoundHandle handle, Duration duration) {
    return _scheduleStop(handle.id, duration.toDouble());
  }

  late final _scheduleStopPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'scheduleStop');
  late final _scheduleStop =
      _scheduleStopPtr.asFunction<int Function(int, double)>();

  /// Set fader to oscillate the volume at specified frequency.
  ///
  int oscillateVolume(
      SoundHandle handle, double from, double to, Duration time) {
    return _oscillateVolume(handle.id, from, to, time.toDouble());
  }

  late final _oscillateVolumePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillateVolume');
  late final _oscillateVolume = _oscillateVolumePtr
      .asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the panning at specified frequency.
  ///
  int oscillatePan(SoundHandle handle, double from, double to, Duration time) {
    return _oscillatePan(handle.id, from, to, time.toDouble());
  }

  late final _oscillatePanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillatePan');
  late final _oscillatePan =
      _oscillatePanPtr.asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the relative play speed at specified frequency.
  ///
  int oscillateRelativePlaySpeed(
      SoundHandle handle, double from, double to, Duration time) {
    return _oscillateRelativePlaySpeed(handle.id, from, to, time.toDouble());
  }

  late final _oscillateRelativePlaySpeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillateRelativePlaySpeed');
  late final _oscillateRelativePlaySpeed = _oscillateRelativePlaySpeedPtr
      .asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the global volume at specified frequency.
  ///
  int oscillateGlobalVolume(double from, double to, Duration time) {
    return _oscillateGlobalVolume(from, to, time.toDouble());
  }

  late final _oscillateGlobalVolumePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Float, ffi.Float, ffi.Float)>>(
      'oscillateGlobalVolume');
  late final _oscillateGlobalVolume = _oscillateGlobalVolumePtr
      .asFunction<int Function(double, double, double)>();

  /////////////////////////////////////////
  /// Filters
  /////////////////////////////////////////

  /// Check if the given filter is active or not.
  ///
  /// [filterType] filter to check
  /// Returns [PlayerErrors.noError] if no errors and the index of
  /// the given filter (-1 if the filter is not active)
  ///
  ({PlayerErrors error, int index}) isFilterActive(int filterType) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Int> id = calloc(ffi.sizeOf<ffi.Int>());
    final e = _isFilterActive(filterType, id);
    final ret = (error: PlayerErrors.values[e], index: id.value);
    calloc.free(id);
    return ret;
  }

  late final _isFilterActivePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int>)>>(
      'isFilterActive');
  late final _isFilterActive =
      _isFilterActivePtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Get parameters names of the given filter.
  ///
  /// [filterType] filter to get param names
  /// Returns [PlayerErrors.noError] if no errors and the list of param names
  ///
  ({PlayerErrors error, List<String> names}) getFilterParamNames(
      int filterType) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Int> paramsCount = calloc(ffi.sizeOf<ffi.Int>());
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Pointer<ffi.Char>> names =
        calloc(ffi.sizeOf<ffi.Char>() * 30);
    _log.fine(() =>
        'PARAMS NAME paramsCount: ${paramsCount.address.toRadixString(16)}  '
        'names: ${names.address.toRadixString(16)}');

    final e = _getFilterParamNames(
      filterType,
      paramsCount,
      names,
    );
    final pNames = <String>[];
    for (var i = 0; i < paramsCount.value; i++) {
      _log.fine(() => 'PARAMS NAME $i ${names + i}   '
          '${names[i].cast<Utf8>().toDartString()}    '
          'names[i]: ${names[i].address.toRadixString(16)}');
      pNames.add(names[i].cast<Utf8>().toDartString());
    }
    final ret = (error: PlayerErrors.values[e], names: pNames);
    calloc.free(paramsCount);
    for (var i = 0; i < pNames.length; i++) {
      calloc.free(names[i]);
    }
    calloc.free(names);
    return ret;
  }

  late final _getFilterParamNamesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getFilterParamNames');
  late final _getFilterParamNames = _getFilterParamNamesPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Add the filter [filterType].
  ///
  /// [filterType] filter to add.
  /// Returns:
  /// [PlayerErrors.noError] if no errors
  /// [PlayerErrors.filterNotFound] if the [filterType] does not exits
  /// [PlayerErrors.filterAlreadyAdded] when trying to add an already
  ///     added filter
  /// [PlayerErrors.maxNumberOfFiltersReached] when the maximum number of
  ///     filters has been reached (default is 8)
  ///
  PlayerErrors addGlobalFilter(int filterType) {
    final e = _addGlobalFilter(filterType);
    return PlayerErrors.values[e];
  }

  late final _addGlobalFilterPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'addGlobalFilter');
  late final _addGlobalFilter =
      _addGlobalFilterPtr.asFunction<int Function(int)>();

  /// Remove the filter [filterType].
  ///
  /// [filterType] filter to remove
  /// Returns [PlayerErrors.noError] if no errors
  ///
  int removeGlobalFilter(int filterType) {
    return _removeGlobalFilter(filterType);
  }

  late final _removeGlobalFilterPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'removeGlobalFilter');
  late final _removeGlobalFilter =
      _removeGlobalFilterPtr.asFunction<int Function(int)>();

  /// Set the effect parameter with id [attributeId]
  /// of [filterType] with [value] value.
  ///
  /// [filterType] filter to modify a param
  /// Returns [PlayerErrors.noError] if no errors
  ///
  int setFilterParams(int filterType, int attributeId, double value) {
    return _setFxParams(filterType, attributeId, value);
  }

  late final _setFxParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int, ffi.Float)>>('setFxParams');
  late final _setFxParams =
      _setFxParamsPtr.asFunction<int Function(int, int, double)>();

  /// Get the effect parameter with id [attributeId] of [filterType].
  ///
  /// [filterType] filter to modify a param
  /// Returns the value of param
  ///
  double getFilterParams(int filterType, int attributeId) {
    return _getFxParams(filterType, attributeId);
  }

  late final _getFxParamsPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Int32, ffi.Int)>>(
          'getFxParams');
  late final _getFxParams =
      _getFxParamsPtr.asFunction<double Function(int, int)>();

  /////////////////////////////////////////
  /// 3D audio methods
  /////////////////////////////////////////

  /// play3d() is the 3d version of the play() call
  ///
  /// [posX], [posY], [posZ] are the audio source position coordinates.
  /// [velX], [velY], [velZ] are the audio source velocity.
  /// [looping] whether to start the sound in looping state.
  /// [loopingStartAt] If looping is enabled, the loop point is, by default,
  /// the start of the stream. The loop start point can be set with this
  /// parameter, and current loop point can be queried with `getLoopingPoint()`
  /// and changed by `setLoopingPoint()`.
  /// Returns the handle of the sound, 0 if error
  ({PlayerErrors error, SoundHandle newHandle}) play3d(
    SoundHash soundHash,
    double posX,
    double posY,
    double posZ, {
    double velX = 0,
    double velY = 0,
    double velZ = 0,
    double volume = 1,
    bool paused = false,
    bool looping = false,
    Duration loopingStartAt = Duration.zero,
  }) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> handle = calloc();
    final e = _play3d(
      soundHash.hash,
      posX,
      posY,
      posZ,
      velX,
      velY,
      velZ,
      volume,
      paused ? 1 : 0,
      looping ? 1 : 0,
      loopingStartAt.toDouble(),
      handle,
    );
    final ret =
        (error: PlayerErrors.values[e], newHandle: SoundHandle(handle.value));
    calloc.free(handle);
    return ret;
  }

  late final _play3dPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.UnsignedInt,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Int,
              ffi.Int,
              ffi.Double,
              ffi.Pointer<ffi.UnsignedInt>)>>('play3d');
  late final _play3d = _play3dPtr.asFunction<
      int Function(int, double, double, double, double, double, double, double,
          int, int, double, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Since SoLoud has no knowledge of the scale of your coordinates,
  /// you may need to adjust the speed of sound for these effects
  /// to work correctly. The default value is 343, which assumes
  /// that your world coordinates are in meters (where 1 unit is 1 meter),
  /// and that the environment is dry air at around 20 degrees Celsius.
  ///
  void set3dSoundSpeed(double speed) {
    return _set3dSoundSpeed(speed);
  }

  late final _set3dSoundSpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
    'set3dSoundSpeed',
  );
  late final _set3dSoundSpeed =
      _set3dSoundSpeedPtr.asFunction<void Function(double)>();

  /// Get the sound speed.
  ///
  double get3dSoundSpeed() {
    return _get3dSoundSpeed();
  }

  late final _get3dSoundSpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function()>>('get3dSoundSpeed');
  late final _get3dSoundSpeed =
      _get3dSoundSpeedPtr.asFunction<double Function()>();

  /// You can set the position, at-vector, up-vector and velocity
  /// parameters of the 3d audio listener with one call
  ///
  void set3dListenerParameters(
    double posX,
    double posY,
    double posZ,
    double atX,
    double atY,
    double atZ,
    double upX,
    double upY,
    double upZ,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dListenerParameters(
      posX,
      posY,
      posZ,
      atX,
      atY,
      atZ,
      upX,
      upY,
      upZ,
      velocityX,
      velocityY,
      velocityZ,
    );
  }

  late final _set3dListenerParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerParameters');
  late final _set3dListenerParameters = _set3dListenerParametersPtr.asFunction<
      void Function(
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
      )>();

  /// You can set the position parameter of the 3d audio listener
  ///
  void set3dListenerPosition(double posX, double posY, double posZ) {
    return _set3dListenerPosition(posX, posY, posZ);
  }

  late final _set3dListenerPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerPosition');
  late final _set3dListenerPosition = _set3dListenerPositionPtr
      .asFunction<void Function(double, double, double)>();

  /// You can set the "at" vector parameter of the 3d audio listener.
  ///
  void set3dListenerAt(double atX, double atY, double atZ) {
    return _set3dListenerAt(atX, atY, atZ);
  }

  late final _set3dListenerAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerAt');
  late final _set3dListenerAt =
      _set3dListenerAtPtr.asFunction<void Function(double, double, double)>();

  /// You can set the "up" vector parameter of the 3d audio listener.
  ///
  void set3dListenerUp(double upX, double upY, double upZ) {
    return _set3dListenerUp(upX, upY, upZ);
  }

  late final _set3dListenerUpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerUp');
  late final _set3dListenerUp =
      _set3dListenerUpPtr.asFunction<void Function(double, double, double)>();

  /// You can set the listener's velocity vector parameter.
  ///
  void set3dListenerVelocity(
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dListenerVelocity(velocityX, velocityY, velocityZ);
  }

  late final _set3dListenerVelocityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerVelocity');
  late final _set3dListenerVelocity = _set3dListenerVelocityPtr
      .asFunction<void Function(double, double, double)>();

  /// You can set the position and velocity parameters of a live
  /// 3d audio source with one call.
  ///
  void set3dSourceParameters(
    SoundHandle handle,
    double posX,
    double posY,
    double posZ,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dSourceParameters(
      handle.id,
      posX,
      posY,
      posZ,
      velocityX,
      velocityY,
      velocityZ,
    );
  }

  late final _set3dSourceParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceParameters');
  late final _set3dSourceParameters = _set3dSourceParametersPtr.asFunction<
      void Function(int, double, double, double, double, double, double)>();

  /// You can set the position parameters of a live 3d audio source
  ///
  void set3dSourcePosition(
      SoundHandle handle, double posX, double posY, double posZ) {
    return _set3dSourcePosition(handle.id, posX, posY, posZ);
  }

  late final _set3dSourcePositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourcePosition');
  late final _set3dSourcePosition = _set3dSourcePositionPtr
      .asFunction<void Function(int, double, double, double)>();

  /// You can set the velocity parameters of a live 3d audio source
  ///
  void set3dSourceVelocity(
    SoundHandle handle,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dSourceVelocity(handle.id, velocityX, velocityY, velocityZ);
  }

  late final _set3dSourceVelocityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceVelocity');
  late final _set3dSourceVelocity = _set3dSourceVelocityPtr
      .asFunction<void Function(int, double, double, double)>();

  /// You can set the minimum and maximum distance parameters
  /// of a live 3d audio source
  ///
  void set3dSourceMinMaxDistance(
    SoundHandle handle,
    double minDistance,
    double maxDistance,
  ) {
    return _set3dSourceMinMaxDistance(handle.id, minDistance, maxDistance);
  }

  late final _set3dSourceMinMaxDistancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceMinMaxDistance');
  late final _set3dSourceMinMaxDistance = _set3dSourceMinMaxDistancePtr
      .asFunction<void Function(int, double, double)>();

  /// You can change the attenuation model and rolloff factor parameters of
  /// a live 3d audio source.
  ///
  /// NO_ATTENUATION 	      No attenuation
  /// INVERSE_DISTANCE 	    Inverse distance attenuation model
  /// LINEAR_DISTANCE 	    Linear distance attenuation model
  /// EXPONENTIAL_DISTANCE 	Exponential distance attenuation model
  ///
  /// see https://solhsa.com/soloud/concepts3d.html
  ///
  void set3dSourceAttenuation(
    SoundHandle handle,
    int attenuationModel,
    double attenuationRolloffFactor,
  ) {
    return _set3dSourceAttenuation(
      handle.id,
      attenuationModel,
      attenuationRolloffFactor,
    );
  }

  late final _set3dSourceAttenuationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Float,
          )>>('set3dSourceAttenuation');
  late final _set3dSourceAttenuation =
      _set3dSourceAttenuationPtr.asFunction<void Function(int, int, double)>();

  /// You can change the doppler factor of a live 3d audio source
  ///
  void set3dSourceDopplerFactor(SoundHandle handle, double dopplerFactor) {
    return _set3dSourceDopplerFactor(handle.id, dopplerFactor);
  }

  late final _set3dSourceDopplerFactorPtr = _lookup<
      ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
    'set3dSourceDopplerFactor',
  );
  late final _set3dSourceDopplerFactor =
      _set3dSourceDopplerFactorPtr.asFunction<void Function(int, double)>();

  /// internal test. Does nothing now
  ///
  void test() {
    return _test();
  }

  late final _testPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('test');
  late final _test = _testPtr.asFunction<void Function()>();
}

/// Used for easier conversion from [double] to [Duration].
extension _DoubleToDuration on double {
  Duration toDuration() {
    return Duration(
        microseconds: (this * Duration.microsecondsPerSecond).round());
  }
}

/// Used for easier conversion from [Duration] to [double].
extension _DurationToDouble on Duration {
  double toDouble() {
    return inMicroseconds / Duration.microsecondsPerSecond;
  }
}
